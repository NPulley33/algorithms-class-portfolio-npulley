using System;
using System.Collections.Generic;
using KarlTeaching;

namespace algo_class_portfolio_npulley.Data_Structure_Differences
{
    public static class DataStructureComparison
    {
        //an array can be filled with values on initilization, unlike other data structures
        static int[] array = new int[] { 1, 2, 3, 4, 5};
        static Dictionary<int, string> map = new Dictionary<int, string>();

        static Stack<int> stack = new Stack<int>();
        static Queue<int> queue = new Queue<int>();

        static DataStructureComparison()
        { 
            InitMap();
            InitQueue();
            InitStack();
        }

        public static void ArrayShuffleAndSort()
        {
            //since arrays have indexing, it allows you to perform unique functions on them
            //one such function is shuffling data around within the array
            //an example of where this might be used is for card games
            FisherYatesShuffle.Shuffle(array);
            
            //TODO: implement own sorting algorithm here
            //indexing in arrays also allows for the much more broadly used function of sorting
            //sorting data is done all the time, and is an extremly important function to have
            Array.Sort(array);

            //add in accessing an element by "Contains"
        }

        public static void DictionaryStoreInfo()
        {
            //maps, hashsets, and dictionaries function similarly in that they all use a hash or key to store and access elements
            //this means you cant access all elements of these data sets unless you know all of the keys or hashs
            //however, it makes accessing elements faster
            //one example of when you would use one of these date structures is somewhere to store passwords
            map.Add(291082012, "MyNewPassword1234");
            //the key could be generated by a hash, and checking to see if a password was entered correctly
            //could be done by checking the corresponding hash instead of the password, therefore protecting it
        }

        public static void StackVsQueue()
        {
            //both stacks and queues allow you to see what is the "first" element in the collection without removing it
            stack.Peek();
            queue.Peek();

            //however even if elements were added in the same order, the "first" element is different because of the difference in ordering
            //Stacks are FILO and Queues are FIFO,
            //so the "first" element in a stack is the last one added, but the "first" element in a queue is the first one added
            stack.Pop();
            queue.Dequeue();

            //the functionality for a stack is most known for stack memory when running a program or application
            //stacks could also be used for anything that needs a FILO collection, such as loading a shotgun in a video game
            //queues are similarly used for anything that needs a FIFO collection, for example a set of step by step instructions
        }



        public static void InitMap()
        {
            map.Add(1, "Password123");
            map.Add(2, "Password456");
            map.Add(3, "Password789");
            map.Add(4, "Zippy123");
            map.Add(5, "Bippy123");
        }

        public static void InitStack()
        { 
            stack.Push(1);
            stack.Push(2);
            stack.Push(3);
            stack.Push(4);
            stack.Push(5);
        }

        public static void InitQueue()
        {
            queue.Enqueue(1);
            queue.Enqueue(2);
            queue.Enqueue(3);
            queue.Enqueue(4);
            queue.Enqueue(5);
        }

    }
}
